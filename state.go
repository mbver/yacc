package main

import (
	"fmt"
	"sort"
)

const STATEINC = 200    // increment of kernel storage
const EPSLINC = 8       // increment of epsilons
const TRANSIZE = 16000  // size of transition storage
const ACTSIZE = 240000  // size of action storage
const ACCEPTCODE = 8191 // code for accept
const ERRCODE = 8190    // code for error
const NTBASE = 010000   // nonterminal symbol has their numeric value >= NTBASE
const WSETINC = 50      // increase for working sets
const NSTATES = 16000   // maximum number of states

// no, left, right, binary assoc.
const (
	NOASC = iota
	LASC
	RASC
	BASC
)

var nstate = 0
var stateChain = make([]int, NSTATES)   // chain states of the same transition symbol together. idx is the state, value is previous state of the same transition symbol
var tstates []int                       // latest state generated by a terminal transition symbol
var ntstates []int                      // latest state generated by a non-terminal transition symbol
var trans []int = make([]int, TRANSIZE) // temporarily store transitions for each symbol after closing a state
var aptPrd []int                        // compact info: associativity, precedence, type, action and reduction flags for a production
var aptTerm []int                       // compact info: associativity, precedence, type of terminal symbols
var kernls []item                       // kernel items storage
var kernlp = make([]int, NSTATES+2)     // items for kernel i is from kernlp[i] to kernlp[i+1]

// the kernel item
type item struct {
	off   int   // position of symbol right after dot
	prd   []int // pointer into prds
	first int   // symbol right after dot
	lkset lkset // lookahead set
}

func (i item) clone() item {
	// lkset will be manipulated in closure. clone it
	return item{i.off, i.prd, i.first, i.lkset.clone()}
}

// string representation with a dot
func (i item) string() string {
	prd := i.prd
	lhs := prd[0] - NTBASE
	res := nonterms[lhs].name + ": "
	var n int

	for j := 1; j < len(prd); j++ {
		n = prd[j]
		sep := ' ' // separator
		if j == i.off {
			sep = '.'
		}
		res += string(sep)
		if n <= 0 {
			break
		}
		res += symbolName(n)
	}

	if prd[i.off] < 0 {
		res += fmt.Sprintf("    (%v)", id(prd))
	}
	return res
}

// epsilons derivations of each state
var epsilons = map[int][]item{}

// add an item to kernel storage
func addKernItem(itemI item) {
	itemI.off++
	itemI.first = itemI.prd[itemI.off]

	i := kernlp[nstate+1]
	if i >= len(kernls) {
		extend(&kernls, STATEINC)
	}
	kernls[i] = itemI.clone()
	kernlp[nstate+1] = i + 1
}

// the workset item
type wItem struct {
	item   item
	closed bool // mark processed during closure
	done   bool // mark done for state generation
}

var wSet []wItem // items generated during closure
var cwp int      // idx of last item generated by a closure
var lksize int   // size of lookahead set
var clkset lkset // temporarily stores lookahead set of a derived item

// stategen generates the LALR(1) kernel items of states. the work üê¥ of the algorithm
func stategen() {
	nstate = 0
	tstates = make([]int, termN+1)     // include 0
	ntstates = make([]int, nontermN+1) // include $accept
	wSet = make([]wItem, nontermN+WSETINC)
	clkset = newLkset()
	addKernItem(item{0, prods[0], 0, newLkset()})
	nstate++
	for i := 0; i < nstate; i++ {
		fill(trans, nontermN+1, 0) // temporary store gotos. $accept included for convenience
		closure1(i)
		for j := 0; j < cwp; j++ {
			w := wSet[j]
			if w.done {
				continue
			}
			w.done = true
			first := w.item.first

			// first can never be 0 because terminal symbol starts from 1.
			// first can never be $accept too. because with production 0: $accept -> program $end, the dot starts from program and move to $end
			if first == 1 {
				continue // skip $end
			}

			if first < 0 { // end of prd after derived
				if j >= kernlp[i+1]-kernlp[i] { // not kernel item of current state
					epsilons[i] = append(epsilons[i], w.item.clone()) // store epsilon for current state
				}
				continue
			}

			kernlp[nstate+1] = kernlp[nstate] // next state hold 0 items initially
			// add all items with the same first symbol into a partition
			addKernItem(w.item)
			for k := j + 1; k < cwp; k++ {
				if first == wSet[k].item.first {
					addKernItem(wSet[k].item)
					wSet[k].done = true
				}
			}
			// create new state with the partition
			s := newState(first)
			if first > NTBASE { // non-terminal symbol
				trans[first-NTBASE] = s // store gotos
			}
		}
		gotoIdx[i] = packGotosRow() - 1 // store index to retrieve goto from actionStore
	}
}

// newState creates a new state for a transtion symbol or merge it with existing state
func newState(sym int) int {
	p1, p2 := kernlp[nstate], kernlp[nstate+1]
	if p1 == p2 { // no items for new state. skip. (just safeguard)
		return 0
	}
	partn := kernls[p1:p2]
	// sort to help search later
	sort.Slice(partn, func(i, j int) bool {
		return id(partn[i].prd) < id(partn[j].prd) ||
			(id(partn[i].prd) == id(partn[j].prd) && partn[i].off < partn[j].off)
	})

	if prev := searchState(nstate, sym); prev > 0 { // found previous state, merge
		q1, q2 := kernlp[prev], kernlp[prev+1]
		kernlp[nstate+1] = kernlp[nstate] // delete current items
		for l, k := q1, p1; l < q2; l, k = l+1, k+1 {
			kernls[l].lkset.union(kernls[k].lkset)
		}
		return prev
	}
	// not found, completely new state!
	if nstate+1 >= NSTATES {
		errorf("too many states")
	}
	if sym >= NTBASE {
		stateChain[nstate] = ntstates[sym-NTBASE]
		ntstates[sym-NTBASE] = nstate
	} else {
		stateChain[nstate] = tstates[sym]
		tstates[sym] = nstate
	}
	nstate++
	return nstate - 1
}

// retrieve existing state for current items
func retrieveState(sym int) int {
	p1, p2 := kernlp[nstate], kernlp[nstate+1]
	defer func() {
		kernlp[nstate+1] = kernlp[nstate] // delete added items
	}()

	if p1 == p2 { // no items for new state. skip. (just safeguard)
		return 0
	}
	partn := kernls[p1:p2]
	// sort to help search later
	sort.Slice(partn, func(i, j int) bool {
		return id(partn[i].prd) < id(partn[j].prd) ||
			(id(partn[i].prd) == id(partn[j].prd) && partn[i].off < partn[j].off)
	})

	if prev := searchState(nstate, sym); prev > 0 { // found previous state, merge
		return prev
	}
	return 0
}

// searchState looks for the identical previous state of the same transition symbol (without considering the lookahead set)
func searchState(n int, sym int) int {
	p1, p2 := kernlp[n], kernlp[n+1]
	var prev int
	if sym >= NTBASE {
		prev = ntstates[sym-NTBASE]
	} else {
		prev = tstates[sym]
	}
prevState:
	for ; prev != 0; prev = stateChain[prev] {
		q1, q2 := kernlp[prev], kernlp[prev+1]
		if (p2 - p1) != (q2 - q1) { // kernels are not the same size
			continue
		}
		for k, l := p1, q1; l < q2; k, l = k+1, l+1 {
			if id(kernls[k].prd) != id(kernls[l].prd) || kernls[k].off != kernls[l].off {
				continue prevState
			}
		}
		return prev
	}

	return -1
}
